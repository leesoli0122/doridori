<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>JS Reference VS Copy</title>
    <link rel="icon" href="https://fav.farm/🔥" />
</head>

<body>

    <script>
        // start with strings, numbers and booleans
        // 문자열, 숫자 및 부울로 시작
        let age = 100;
        let age2 = age; //age값을 age2에 복사
        console.log(age, age2);// 100, 100
        age = 200; //age값을 변경
        console.log(age, age2);// 200, 100

        let name = 'wes';
        let name2 = name; //name값을 name2에 복사
        console.log(name, name2);// wes, wes
        name = 'wesley';//name값을 변경
        console.log(name, name2);// wesley, wes

        // age와 name값을 변경했는데 age2와 name2의 값은 변하지 않는 이유(원시 값(Primitive types)의 복사 : age, name과 같은 원시 값은 복사 시 독립적인 값을 가집니다. 값을 변경해도 복사본에는 영향을 미치지 않습니다

        // Let's say we have an array
        // 배열이 있다고 가정 해 보자
        const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

        // and we want to make a copy of it.
        // 복사본을 만들고 싶다
        const team = players;
        console.log(players, team);// (4)['Wes', 'Sarah', 'Ryan', 'Poppy'], (4)['Wes', 'Sarah', 'Ryan', 'Poppy']
        // 참조 값(Reference types)의 복사: 배열이나 객체와 같은 참조 타입은 복사 시 메모리 주소를 공유하게 됩니다. 따라서 하나를 수정하면 다른 것에도 영향을 미칩니다.
        
        //team[3] = 'Lux'; // 이 코드를 실행하면 team 배열의 요소를 변경하지만, players 배열도 같이 변경됨
        console.log(players, team);// (4)['Wes', 'Sarah', 'Ryan', 'Lux'], (4)['Wes', 'Sarah', 'Ryan', 'Lux']

        // however what happens when we update that array?
        // 그러나 그 배열을 업데이트하면 어떻게 될까?

        // 이제 여기 문제가 있다
        // 원본 배열(players)도 수정됨

        // 이유: team은 players의 참조를 복사했기 때문에, 같은 메모리 주소를 가리키고 있음. 즉, 배열의 실제 데이터를 공유함.

        // 해결책: 배열의 복사를 해야 함 (참조가 아닌 독립된 복사본을 생성)
        const team2 = players.slice(); // slice() 메서드를 사용하여 새로운 배열을 생성 (얕은 복사)

        // 다른 방법으로 배열 복사
        // 새로운 배열을 만들고, 기존 배열을 concat으로 합침
        const team3 = [].concat(players);
        console.log(team3);

        // 또는 ES6 스프레드 연산자를 사용
        const team4 = [...players]; // 스프레드 문법을 사용하여 새로운 배열 생성 (얕은 복사)
        team4[3] = 'hawww'; // team4 배열의 요소를 변경
        console.log(team4); // 변경된 team4 배열 출력 (4)['Wes', 'Sarah', 'Ryan', 'hawww']

        const team5 = Array.from(players); // Array.from()을 사용하여 배열을 복사
        console.log(team5);// (4)['Wes', 'Sarah', 'Ryan', 'Poppy']

        // now when we update it, the original one isn't changed
        // 이제 업데이트 할 때 원본은 변경되지 않다

        // 객체 예시(참조의 복사)

        // with Objects
        const person = {
            name: 'Wes Bos',
            age: 80
        };

        // and think we make a copy:
        // 사본을 만든다고 생각한다.
        const captain = person;
        console.log(captain);// {name: 'Wes Bos', age: 80}
        //captain.number = 99; // cacaptain 객체에 number 속성을 추가하면, person 객체에도 영향을 미침

        // 객체 복사 방법 (올바른 방법) Object.assign( { }, 참조 객체, 추가할 값)
        const cap2 = Object.assign({}, person, {number: 99, age: 12});// Object.assign()을 사용하여 새로운 객체를 생성하고, person 객체의 내용을 복사, 추가 속성(number와 age)을 덮어씀
        console.log(captain, cap2);//{name: 'Wes Bos', age: 80}, {name: 'Wes Bos', age: 12, number: 99}

        // ES6 스프레드 문법을 사용하여 객체 복사 가능 (예시로 주석 처리됨)
        const cap3 = {...person};
        console.log(cap3);//{name: 'Wes Bos', age: 80}

        // 참고: 배열과 객체 모두 얕은 복사만 수행됨. 즉, 중첩된 객체나 배열이 있을 경우, 내부 객체는 참조로 복사됨.
        // lodash의 cloneDeep() 함수는 깊은 복사를 지원하지만, 사용하기 전에 신중하게 고려해야 함.

        const wes = {
            name: 'Wes',
            age: 100,
            social: {
                twitter: '@wesbos',
                facebook: 'wesbos.developer'
            }
        }; // 중첩 객체가 있는 객체 생성

        console.clear(); //콘솔 기록 지움
        console.log(wes);//wes 객체 출력

        // 얕은 복사(내부 객체는 참조로 복사됨)
        const dev = Object.assign({}, wes); // Object.assign()을 사용하여 wes객체를 얕은 복사

        // 깊은 복사(내부 객체도 새로운 객체로 복사됨)
        const dev2 = JSON.parse(JSON.stringify(wes));
        // JSON.stringify()로 객체를 문자열로 변환한 후, JSON.parse()로 다시 객체로 변환하여 깊은 복사 수행
        console.log(dev, dev2);//{name: 'Wes', age: 100, social: {…}}, {name: 'Wes', age: 100, social: {…}}

    </script>

</body>

</html>